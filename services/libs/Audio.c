/* Audio.c generated by valac 0.56.16, the Vala compiler
 * generated from Audio.vala, do not modify */

#include "Audio.h"
#include <pulse/pulseaudio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include "Utils.h"
#include <glib-object.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif

enum  {
	AUDIO_0_PROPERTY,
	AUDIO_SINKS_PROPERTY,
	AUDIO_DEFAULT_SINK_NAME_PROPERTY,
	AUDIO_DEFAULT_SINK_ID_PROPERTY,
	AUDIO_DEFAULT_SINK_ICON_NAME_PROPERTY,
	AUDIO_DEFAULT_SINK_VOLUME_PROPERTY,
	AUDIO_DEFAULT_SINK_MUTE_PROPERTY,
	AUDIO_NUM_PROPERTIES
};
static GParamSpec* audio_properties[AUDIO_NUM_PROPERTIES];
#define _pa_mainloop_free0(var) ((var == NULL) ? NULL : (var = (pa_mainloop_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
#define _pa_context_unref0(var) ((var == NULL) ? NULL : (var = (pa_context_unref (var), NULL)))
#define _pa_operation_unref0(var) ((var == NULL) ? NULL : (var = (pa_operation_unref (var), NULL)))
enum  {
	AUDIO_SIG_STATE_UNCONNECTED_SIGNAL,
	AUDIO_SIG_STATE_CONNECTING_SIGNAL,
	AUDIO_SIG_STATE_AUTHORIZING_SIGNAL,
	AUDIO_SIG_STATE_SETTING_NAME_SIGNAL,
	AUDIO_SIG_STATE_READY_SIGNAL,
	AUDIO_SIG_STATE_FAILED_SIGNAL,
	AUDIO_SIG_STATE_TERMINATED_SIGNAL,
	AUDIO_SIG_DEFAULT_SINK_CHANGE_SIGNAL,
	AUDIO_SIG_DEFAULT_SINK_VOL_CHANGE_SIGNAL,
	AUDIO_SIG_DEFAULT_SINK_MUTE_CHANGE_SIGNAL,
	AUDIO_NUM_SIGNALS
};
static guint audio_signals[AUDIO_NUM_SIGNALS] = {0};

struct _AudioPrivate {
	pa_mainloop* loop;
	gchar** _sinks;
	gint _sinks_length1;
	gint __sinks_size_;
	gint sinks_length;
	gchar* _default_sink_name;
	gint _default_sink_id;
	gchar* _default_sink_icon_name;
	gint _default_sink_volume;
	gboolean _default_sink_mute;
};

static gint Audio_private_offset;
static gpointer audio_parent_class = NULL;

static void audio_run (Audio* self);
static gpointer _audio_run_gthread_func (gpointer self);
static void audio_set_sinks (Audio* self,
                      gchar** value,
                      gint value_length1);
static void _audio_state_callback_pa_context_notify_cb_t (pa_context* c,
                                                   gpointer self);
static void _audio_subscribe_callback_pa_context_subscribe_cb_t (pa_context* c,
                                                          pa_subscription_event_type_t t,
                                                          guint32 idx,
                                                          gpointer self);
static void audio_update (Audio* self,
                   pa_context* context);
static void audio_set_default_sink_name (Audio* self,
                                  const gchar* value);
static void audio_set_default_sink_id (Audio* self,
                                gint value);
static void audio_set_default_sink_volume (Audio* self,
                                    gint value);
static void audio_set_default_sink_mute (Audio* self,
                                  gboolean value);
static void audio_set_default_sink_icon_name (Audio* self,
                                       const gchar* value);
static void audio_get_default_sink (Audio* self,
                             pa_context* context);
static void _audio_default_sink_callback_pa_sink_info_cb_t (pa_context* c,
                                                     pa_sink_info* i,
                                                     gint eol,
                                                     gpointer self);
static void _audio_sinks_list_callback_pa_sink_info_cb_t (pa_context* c,
                                                   pa_sink_info* i,
                                                   gint eol,
                                                   gpointer self);
static gchar** _vala_array_dup1 (gchar** self,
                          gssize length);
static void g_cclosure_user_marshal_VOID__STRING_INT (GClosure * closure,
                                               GValue * return_value,
                                               guint n_param_values,
                                               const GValue * param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);
static void audio_finalize (GObject * obj);
static GType audio_get_type_once (void);
static void _vala_audio_get_property (GObject * object,
                               guint property_id,
                               GValue * value,
                               GParamSpec * pspec);
static void _vala_audio_set_property (GObject * object,
                               guint property_id,
                               const GValue * value,
                               GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
audio_get_instance_private (Audio* self)
{
	return G_STRUCT_MEMBER_P (self, Audio_private_offset);
}

static gpointer
_audio_run_gthread_func (gpointer self)
{
	gpointer result;
	audio_run ((Audio*) self);
	result = NULL;
	g_object_unref (self);
	return result;
}

void
audio_start (Audio* self)
{
	GThread* thread = NULL;
	GThread* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_thread_new ("audio", _audio_run_gthread_func, g_object_ref (self));
	thread = _tmp0_;
	_g_thread_unref0 (thread);
}

static void
_audio_state_callback_pa_context_notify_cb_t (pa_context* c,
                                              gpointer self)
{
	audio_state_callback ((Audio*) self, c);
}

static void
audio_run (Audio* self)
{
	pa_mainloop* _tmp0_;
	gchar** _tmp1_;
	gchar** _tmp2_;
	gint _tmp2__length1;
	pa_context* con = NULL;
	pa_mainloop* _tmp3_;
	pa_mainloop_api* _tmp4_;
	pa_context* _tmp5_;
	pa_mainloop* _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = pa_mainloop_new ();
	_pa_mainloop_free0 (self->priv->loop);
	self->priv->loop = _tmp0_;
	_tmp1_ = g_new0 (gchar*, 10 + 1);
	_tmp2_ = _tmp1_;
	_tmp2__length1 = 10;
	audio_set_sinks (self, _tmp2_, 10);
	_tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL);
	_tmp3_ = self->priv->loop;
	_tmp4_ = pa_mainloop_get_api (_tmp3_);
	_tmp5_ = pa_context_new_with_proplist (_tmp4_, "Audio", NULL);
	con = _tmp5_;
	pa_context_connect (con, NULL, PA_CONTEXT_NOFAIL, NULL);
	pa_context_set_state_callback (con, _audio_state_callback_pa_context_notify_cb_t, self);
	_tmp6_ = self->priv->loop;
	pa_mainloop_run (_tmp6_, NULL);
	_pa_context_unref0 (con);
}

gchar*
audio_set_sink_default_volume (Audio* self,
                               gint volume)
{
	gboolean _tmp0_ = FALSE;
	gchar* _tmp12_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (0 <= volume) {
		_tmp0_ = volume <= 100;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar** _tmp8_;
		gchar** _tmp9_;
		gint _tmp9__length1;
		gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp1_ = g_strdup ("pactl");
		_tmp2_ = g_strdup ("set-sink-volume");
		_tmp3_ = self->priv->_default_sink_name;
		_tmp4_ = g_strdup (_tmp3_);
		_tmp5_ = g_strdup_printf ("%i", volume);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_strconcat (_tmp6_, "%", NULL);
		_tmp8_ = g_new0 (gchar*, 4 + 1);
		_tmp8_[0] = _tmp1_;
		_tmp8_[1] = _tmp2_;
		_tmp8_[2] = _tmp4_;
		_tmp8_[3] = _tmp7_;
		_tmp9_ = _tmp8_;
		_tmp9__length1 = 4;
		_tmp10_ = utils_exec (_tmp9_, (gint) 4);
		_tmp11_ = _tmp10_;
		_tmp9_ = (_vala_array_free (_tmp9_, _tmp9__length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp6_);
		result = _tmp11_;
		return result;
	}
	_tmp12_ = g_strdup ("Volume out of bounds\n");
	result = _tmp12_;
	return result;
}

gchar*
audio_set_sink_default_volume_inc (Audio* self,
                                   gint volume)
{
	gboolean _tmp0_ = FALSE;
	gchar* _tmp12_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (0 <= volume) {
		_tmp0_ = volume <= 10;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar** _tmp8_;
		gchar** _tmp9_;
		gint _tmp9__length1;
		gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp1_ = g_strdup ("pactl");
		_tmp2_ = g_strdup ("set-sink-volume");
		_tmp3_ = self->priv->_default_sink_name;
		_tmp4_ = g_strdup (_tmp3_);
		_tmp5_ = g_strdup_printf ("%i", volume);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_strconcat ("+", _tmp6_, "%", NULL);
		_tmp8_ = g_new0 (gchar*, 4 + 1);
		_tmp8_[0] = _tmp1_;
		_tmp8_[1] = _tmp2_;
		_tmp8_[2] = _tmp4_;
		_tmp8_[3] = _tmp7_;
		_tmp9_ = _tmp8_;
		_tmp9__length1 = 4;
		_tmp10_ = utils_exec (_tmp9_, (gint) 4);
		_tmp11_ = _tmp10_;
		_tmp9_ = (_vala_array_free (_tmp9_, _tmp9__length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp6_);
		result = _tmp11_;
		return result;
	}
	_tmp12_ = g_strdup ("Volume out of bounds\n");
	result = _tmp12_;
	return result;
}

gchar*
audio_set_sink_default_volume_dec (Audio* self,
                                   gint volume)
{
	gboolean _tmp0_ = FALSE;
	gchar* _tmp12_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (0 <= volume) {
		_tmp0_ = volume <= 10;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar** _tmp8_;
		gchar** _tmp9_;
		gint _tmp9__length1;
		gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp1_ = g_strdup ("pactl");
		_tmp2_ = g_strdup ("set-sink-volume");
		_tmp3_ = self->priv->_default_sink_name;
		_tmp4_ = g_strdup (_tmp3_);
		_tmp5_ = g_strdup_printf ("%i", volume);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_strconcat ("-", _tmp6_, "%", NULL);
		_tmp8_ = g_new0 (gchar*, 4 + 1);
		_tmp8_[0] = _tmp1_;
		_tmp8_[1] = _tmp2_;
		_tmp8_[2] = _tmp4_;
		_tmp8_[3] = _tmp7_;
		_tmp9_ = _tmp8_;
		_tmp9__length1 = 4;
		_tmp10_ = utils_exec (_tmp9_, (gint) 4);
		_tmp11_ = _tmp10_;
		_tmp9_ = (_vala_array_free (_tmp9_, _tmp9__length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp6_);
		result = _tmp11_;
		return result;
	}
	_tmp12_ = g_strdup ("Volume out of bounds\n");
	result = _tmp12_;
	return result;
}

static gchar*
bool_to_string (gboolean self)
{
	gchar* result;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}

gchar*
audio_set_sink_default_mute (Audio* self,
                             gboolean mute)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar** _tmp5_;
	gchar** _tmp6_;
	gint _tmp6__length1;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("pactl");
	_tmp1_ = g_strdup ("set-sink-mute");
	_tmp2_ = self->priv->_default_sink_name;
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = bool_to_string (mute);
	_tmp5_ = g_new0 (gchar*, 4 + 1);
	_tmp5_[0] = _tmp0_;
	_tmp5_[1] = _tmp1_;
	_tmp5_[2] = _tmp3_;
	_tmp5_[3] = _tmp4_;
	_tmp6_ = _tmp5_;
	_tmp6__length1 = 4;
	_tmp7_ = utils_exec (_tmp6_, (gint) 4);
	_tmp8_ = _tmp7_;
	_tmp6_ = (_vala_array_free (_tmp6_, _tmp6__length1, (GDestroyNotify) g_free), NULL);
	result = _tmp8_;
	return result;
}

gchar*
audio_set_sink_default_toggle_mute (Audio* self)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar** _tmp5_;
	gchar** _tmp6_;
	gint _tmp6__length1;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("pactl");
	_tmp1_ = g_strdup ("set-sink-mute");
	_tmp2_ = self->priv->_default_sink_name;
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = g_strdup ("toggle");
	_tmp5_ = g_new0 (gchar*, 4 + 1);
	_tmp5_[0] = _tmp0_;
	_tmp5_[1] = _tmp1_;
	_tmp5_[2] = _tmp3_;
	_tmp5_[3] = _tmp4_;
	_tmp6_ = _tmp5_;
	_tmp6__length1 = 4;
	_tmp7_ = utils_exec (_tmp6_, (gint) 4);
	_tmp8_ = _tmp7_;
	_tmp6_ = (_vala_array_free (_tmp6_, _tmp6__length1, (GDestroyNotify) g_free), NULL);
	result = _tmp8_;
	return result;
}

static void
_audio_subscribe_callback_pa_context_subscribe_cb_t (pa_context* c,
                                                     pa_subscription_event_type_t t,
                                                     guint32 idx,
                                                     gpointer self)
{
	audio_subscribe_callback ((Audio*) self, c, t, idx);
}

void
audio_state_callback (Audio* self,
                      pa_context* con)
{
	pa_context_state_t state = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (con != NULL);
	state = pa_context_get_state (con);
	if (state == PA_CONTEXT_UNCONNECTED) {
		g_signal_emit (self, audio_signals[AUDIO_SIG_STATE_UNCONNECTED_SIGNAL], 0);
	}
	if (state == PA_CONTEXT_CONNECTING) {
		g_signal_emit (self, audio_signals[AUDIO_SIG_STATE_CONNECTING_SIGNAL], 0);
	}
	if (state == PA_CONTEXT_AUTHORIZING) {
		g_signal_emit (self, audio_signals[AUDIO_SIG_STATE_AUTHORIZING_SIGNAL], 0);
	}
	if (state == PA_CONTEXT_SETTING_NAME) {
		g_signal_emit (self, audio_signals[AUDIO_SIG_STATE_SETTING_NAME_SIGNAL], 0);
	}
	if (state == PA_CONTEXT_READY) {
		pa_operation* _tmp0_;
		pa_operation* _tmp1_;
		_tmp0_ = pa_context_subscribe (con, PA_SUBSCRIPTION_MASK_SINK, NULL, NULL);
		_tmp1_ = _tmp0_;
		_pa_operation_unref0 (_tmp1_);
		pa_context_set_subscribe_callback (con, _audio_subscribe_callback_pa_context_subscribe_cb_t, self);
		g_signal_emit (self, audio_signals[AUDIO_SIG_STATE_READY_SIGNAL], 0);
		audio_update (self, con);
	}
	if (state == PA_CONTEXT_FAILED) {
		g_signal_emit (self, audio_signals[AUDIO_SIG_STATE_FAILED_SIGNAL], 0);
	}
	if (state == PA_CONTEXT_TERMINATED) {
		g_signal_emit (self, audio_signals[AUDIO_SIG_STATE_TERMINATED_SIGNAL], 0);
	}
}

static gchar*
pulse_audio_volume_sprint (pa_volume_t self)
{
	gchar* buffer = NULL;
	gchar* _tmp0_;
	gint buffer_length1;
	gint _buffer_size_;
	gchar* _tmp1_;
	gchar* result;
	_tmp0_ = g_new0 (gchar, PA_VOLUME_SNPRINT_MAX);
	buffer = _tmp0_;
	buffer_length1 = PA_VOLUME_SNPRINT_MAX;
	_buffer_size_ = buffer_length1;
	pa_volume_snprint (buffer, (gint) buffer_length1, self);
	_tmp1_ = g_strdup ((const gchar*) buffer);
	result = _tmp1_;
	buffer = (g_free (buffer), NULL);
	return result;
}

static gchar*
pulse_audio_volume_to_string (pa_volume_t self)
{
	gchar* _tmp0_;
	gchar* result;
	_tmp0_ = pulse_audio_volume_sprint (self);
	result = _tmp0_;
	return result;
}

static gchar*
string_chug (const gchar* self)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strchug (_result_);
	result = _result_;
	return result;
}

void
audio_default_sink_callback (Audio* self,
                             pa_context* c,
                             pa_sink_info* i,
                             gint eol)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (c != NULL);
	if (i != NULL) {
		gboolean sink_changed = FALSE;
		const gchar* _tmp0_;
		const gchar* _tmp1_;
		pa_cvolume volume = {0};
		pa_cvolume _tmp4_;
		gint vol = 0;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gint _tmp9_;
		gboolean _tmp10_ = FALSE;
		gint _tmp11_;
		gboolean _tmp13_ = FALSE;
		gboolean _tmp14_;
		_tmp0_ = self->priv->_default_sink_name;
		_tmp1_ = (*i).name;
		sink_changed = g_strcmp0 (_tmp0_, _tmp1_) != 0;
		if (sink_changed) {
			const gchar* _tmp2_;
			const gchar* _tmp3_;
			_tmp2_ = (*i).name;
			audio_set_default_sink_name (self, _tmp2_);
			audio_set_default_sink_id (self, (gint) (*i).index);
			_tmp3_ = (*i).name;
			g_signal_emit (self, audio_signals[AUDIO_SIG_DEFAULT_SINK_CHANGE_SIGNAL], 0, _tmp3_, (gint) (*i).index);
		}
		_tmp4_ = (*i).volume;
		volume = _tmp4_;
		_tmp5_ = pulse_audio_volume_to_string (pa_cvolume_avg (&volume));
		_tmp6_ = _tmp5_;
		_tmp7_ = string_chug (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = atoi (_tmp8_);
		_g_free0 (_tmp8_);
		_g_free0 (_tmp6_);
		vol = _tmp9_;
		_tmp11_ = self->priv->_default_sink_volume;
		if (_tmp11_ != vol) {
			_tmp10_ = TRUE;
		} else {
			_tmp10_ = sink_changed;
		}
		if (_tmp10_) {
			gint _tmp12_;
			audio_set_default_sink_volume (self, vol);
			_tmp12_ = self->priv->_default_sink_volume;
			g_signal_emit (self, audio_signals[AUDIO_SIG_DEFAULT_SINK_VOL_CHANGE_SIGNAL], 0, _tmp12_);
		}
		_tmp14_ = self->priv->_default_sink_mute;
		if (_tmp14_ != pa_cvolume_is_muted (&volume)) {
			_tmp13_ = TRUE;
		} else {
			_tmp13_ = sink_changed;
		}
		if (_tmp13_) {
			gboolean _tmp15_;
			audio_set_default_sink_mute (self, pa_cvolume_is_muted (&volume));
			_tmp15_ = self->priv->_default_sink_mute;
			g_signal_emit (self, audio_signals[AUDIO_SIG_DEFAULT_SINK_MUTE_CHANGE_SIGNAL], 0, _tmp15_);
		}
		audio_set_default_sink_icon_name (self, PA_PROP_APPLICATION_ICON_NAME);
	}
}

static void
_audio_default_sink_callback_pa_sink_info_cb_t (pa_context* c,
                                                pa_sink_info* i,
                                                gint eol,
                                                gpointer self)
{
	audio_default_sink_callback ((Audio*) self, c, i, eol);
}

static void
audio_get_default_sink (Audio* self,
                        pa_context* context)
{
	gchar* sink_name = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar** _tmp2_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gchar* _tmp4_;
	gchar* _tmp5_;
	pa_operation* _tmp6_;
	pa_operation* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = g_strdup ("pactl");
	_tmp1_ = g_strdup ("get-default-sink");
	_tmp2_ = g_new0 (gchar*, 2 + 1);
	_tmp2_[0] = _tmp0_;
	_tmp2_[1] = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp3__length1 = 2;
	_tmp4_ = utils_exec (_tmp3_, (gint) 2);
	_tmp5_ = _tmp4_;
	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
	sink_name = _tmp5_;
	_tmp6_ = pa_context_get_sink_info_by_name (context, sink_name, _audio_default_sink_callback_pa_sink_info_cb_t, self);
	_tmp7_ = _tmp6_;
	_pa_operation_unref0 (_tmp7_);
	_g_free0 (sink_name);
}

void
audio_sinks_list_callback (Audio* self,
                           pa_context* context,
                           pa_sink_info* i,
                           gint eol)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	if (i != NULL) {
		gchar** _tmp0_;
		gint _tmp0__length1;
		gint _tmp1_ = 0;
		gchar** _tmp2_;
		gint _tmp2__length1;
		gint _tmp3_;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		_tmp0_ = audio_get_sinks (self, &_tmp1_);
		_tmp0__length1 = _tmp1_;
		_tmp2_ = _tmp0_;
		_tmp2__length1 = _tmp0__length1;
		_tmp3_ = self->priv->sinks_length;
		self->priv->sinks_length = _tmp3_ + 1;
		_tmp4_ = (*i).name;
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (_tmp2_[_tmp3_]);
		_tmp2_[_tmp3_] = _tmp5_;
	}
}

static void
_audio_sinks_list_callback_pa_sink_info_cb_t (pa_context* c,
                                              pa_sink_info* i,
                                              gint eol,
                                              gpointer self)
{
	audio_sinks_list_callback ((Audio*) self, c, i, eol);
}

static void
audio_update (Audio* self,
              pa_context* context)
{
	pa_operation* _tmp0_;
	pa_operation* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	self->priv->sinks_length = 0;
	_tmp0_ = pa_context_get_sink_info_list (context, _audio_sinks_list_callback_pa_sink_info_cb_t, self);
	_tmp1_ = _tmp0_;
	_pa_operation_unref0 (_tmp1_);
	audio_get_default_sink (self, context);
}

void
audio_subscribe_callback (Audio* self,
                          pa_context* context,
                          pa_subscription_event_type_t e,
                          guint32 id)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	if (e == PA_SUBSCRIPTION_EVENT_CHANGE) {
		audio_update (self, context);
	}
}

Audio*
audio_construct (GType object_type)
{
	Audio * self = NULL;
	self = (Audio*) g_object_new (object_type, NULL);
	return self;
}

Audio*
audio_new (void)
{
	return audio_construct (TYPE_AUDIO);
}

gchar**
audio_get_sinks (Audio* self,
                 gint* result_length1)
{
	gchar** result;
	gchar** _tmp0_;
	gint _tmp0__length1;
	gchar** _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_sinks;
	_tmp0__length1 = self->priv->_sinks_length1;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}

static gchar**
_vala_array_dup1 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static void
audio_set_sinks (Audio* self,
                 gchar** value,
                 gint value_length1)
{
	gchar** old_value;
	gint old_value_length;
	g_return_if_fail (self != NULL);
	old_value = audio_get_sinks (self, &old_value_length);
	if (old_value != value) {
		gchar** _tmp0_;
		gint _tmp0__length1;
		_tmp0_ = (value != NULL) ? _vala_array_dup1 (value, value_length1) : value;
		_tmp0__length1 = value_length1;
		self->priv->_sinks = (_vala_array_free (self->priv->_sinks, self->priv->_sinks_length1, (GDestroyNotify) g_free), NULL);
		self->priv->_sinks = _tmp0_;
		self->priv->_sinks_length1 = _tmp0__length1;
		self->priv->__sinks_size_ = self->priv->_sinks_length1;
		g_object_notify_by_pspec ((GObject *) self, audio_properties[AUDIO_SINKS_PROPERTY]);
	}
}

const gchar*
audio_get_default_sink_name (Audio* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_default_sink_name;
	result = _tmp0_;
	return result;
}

static void
audio_set_default_sink_name (Audio* self,
                             const gchar* value)
{
	gchar* old_value;
	g_return_if_fail (self != NULL);
	old_value = audio_get_default_sink_name (self);
	if (g_strcmp0 (value, old_value) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_default_sink_name);
		self->priv->_default_sink_name = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, audio_properties[AUDIO_DEFAULT_SINK_NAME_PROPERTY]);
	}
}

gint
audio_get_default_sink_id (Audio* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_default_sink_id;
	return result;
}

static void
audio_set_default_sink_id (Audio* self,
                           gint value)
{
	gint old_value;
	g_return_if_fail (self != NULL);
	old_value = audio_get_default_sink_id (self);
	if (old_value != value) {
		self->priv->_default_sink_id = value;
		g_object_notify_by_pspec ((GObject *) self, audio_properties[AUDIO_DEFAULT_SINK_ID_PROPERTY]);
	}
}

const gchar*
audio_get_default_sink_icon_name (Audio* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_default_sink_icon_name;
	result = _tmp0_;
	return result;
}

static void
audio_set_default_sink_icon_name (Audio* self,
                                  const gchar* value)
{
	gchar* old_value;
	g_return_if_fail (self != NULL);
	old_value = audio_get_default_sink_icon_name (self);
	if (g_strcmp0 (value, old_value) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_default_sink_icon_name);
		self->priv->_default_sink_icon_name = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, audio_properties[AUDIO_DEFAULT_SINK_ICON_NAME_PROPERTY]);
	}
}

gint
audio_get_default_sink_volume (Audio* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_default_sink_volume;
	return result;
}

static void
audio_set_default_sink_volume (Audio* self,
                               gint value)
{
	gint old_value;
	g_return_if_fail (self != NULL);
	old_value = audio_get_default_sink_volume (self);
	if (old_value != value) {
		self->priv->_default_sink_volume = value;
		g_object_notify_by_pspec ((GObject *) self, audio_properties[AUDIO_DEFAULT_SINK_VOLUME_PROPERTY]);
	}
}

gboolean
audio_get_default_sink_mute (Audio* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_default_sink_mute;
	return result;
}

static void
audio_set_default_sink_mute (Audio* self,
                             gboolean value)
{
	gboolean old_value;
	g_return_if_fail (self != NULL);
	old_value = audio_get_default_sink_mute (self);
	if (old_value != value) {
		self->priv->_default_sink_mute = value;
		g_object_notify_by_pspec ((GObject *) self, audio_properties[AUDIO_DEFAULT_SINK_MUTE_PROPERTY]);
	}
}

static void
g_cclosure_user_marshal_VOID__STRING_INT (GClosure * closure,
                                          GValue * return_value,
                                          guint n_param_values,
                                          const GValue * param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__STRING_INT) (gpointer data1, const char* arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_int (param_values + 2), data2);
}

static void
audio_class_init (AudioClass * klass,
                  gpointer klass_data)
{
	audio_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &Audio_private_offset);
	G_OBJECT_CLASS (klass)->get_property = _vala_audio_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_audio_set_property;
	G_OBJECT_CLASS (klass)->finalize = audio_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUDIO_SINKS_PROPERTY, audio_properties[AUDIO_SINKS_PROPERTY] = g_param_spec_boxed ("sinks", "sinks", "sinks", G_TYPE_STRV, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUDIO_DEFAULT_SINK_NAME_PROPERTY, audio_properties[AUDIO_DEFAULT_SINK_NAME_PROPERTY] = g_param_spec_string ("default-sink-name", "default-sink-name", "default-sink-name", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUDIO_DEFAULT_SINK_ID_PROPERTY, audio_properties[AUDIO_DEFAULT_SINK_ID_PROPERTY] = g_param_spec_int ("default-sink-id", "default-sink-id", "default-sink-id", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUDIO_DEFAULT_SINK_ICON_NAME_PROPERTY, audio_properties[AUDIO_DEFAULT_SINK_ICON_NAME_PROPERTY] = g_param_spec_string ("default-sink-icon-name", "default-sink-icon-name", "default-sink-icon-name", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUDIO_DEFAULT_SINK_VOLUME_PROPERTY, audio_properties[AUDIO_DEFAULT_SINK_VOLUME_PROPERTY] = g_param_spec_int ("default-sink-volume", "default-sink-volume", "default-sink-volume", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), AUDIO_DEFAULT_SINK_MUTE_PROPERTY, audio_properties[AUDIO_DEFAULT_SINK_MUTE_PROPERTY] = g_param_spec_boolean ("default-sink-mute", "default-sink-mute", "default-sink-mute", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	audio_signals[AUDIO_SIG_STATE_UNCONNECTED_SIGNAL] = g_signal_new ("sig-state-unconnected", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	audio_signals[AUDIO_SIG_STATE_CONNECTING_SIGNAL] = g_signal_new ("sig-state-connecting", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	audio_signals[AUDIO_SIG_STATE_AUTHORIZING_SIGNAL] = g_signal_new ("sig-state-authorizing", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	audio_signals[AUDIO_SIG_STATE_SETTING_NAME_SIGNAL] = g_signal_new ("sig-state-setting-name", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	audio_signals[AUDIO_SIG_STATE_READY_SIGNAL] = g_signal_new ("sig-state-ready", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	audio_signals[AUDIO_SIG_STATE_FAILED_SIGNAL] = g_signal_new ("sig-state-failed", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	audio_signals[AUDIO_SIG_STATE_TERMINATED_SIGNAL] = g_signal_new ("sig-state-terminated", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	audio_signals[AUDIO_SIG_DEFAULT_SINK_CHANGE_SIGNAL] = g_signal_new ("sig-default-sink-change", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_INT, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_INT);
	audio_signals[AUDIO_SIG_DEFAULT_SINK_VOL_CHANGE_SIGNAL] = g_signal_new ("sig-default-sink-vol-change", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	audio_signals[AUDIO_SIG_DEFAULT_SINK_MUTE_CHANGE_SIGNAL] = g_signal_new ("sig-default-sink-mute-change", TYPE_AUDIO, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOOLEAN, G_TYPE_NONE, 1, G_TYPE_BOOLEAN);
}

static void
audio_instance_init (Audio * self,
                     gpointer klass)
{
	self->priv = audio_get_instance_private (self);
	self->priv->sinks_length = 0;
}

static void
audio_finalize (GObject * obj)
{
	Audio * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_AUDIO, Audio);
	_pa_mainloop_free0 (self->priv->loop);
	self->priv->_sinks = (_vala_array_free (self->priv->_sinks, self->priv->_sinks_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->priv->_default_sink_name);
	_g_free0 (self->priv->_default_sink_icon_name);
	G_OBJECT_CLASS (audio_parent_class)->finalize (obj);
}

static GType
audio_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (AudioClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) audio_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Audio), 0, (GInstanceInitFunc) audio_instance_init, NULL };
	GType audio_type_id;
	audio_type_id = g_type_register_static (G_TYPE_OBJECT, "Audio", &g_define_type_info, 0);
	Audio_private_offset = g_type_add_instance_private (audio_type_id, sizeof (AudioPrivate));
	return audio_type_id;
}

GType
audio_get_type (void)
{
	static volatile gsize audio_type_id__once = 0;
	if (g_once_init_enter (&audio_type_id__once)) {
		GType audio_type_id;
		audio_type_id = audio_get_type_once ();
		g_once_init_leave (&audio_type_id__once, audio_type_id);
	}
	return audio_type_id__once;
}

static void
_vala_audio_get_property (GObject * object,
                          guint property_id,
                          GValue * value,
                          GParamSpec * pspec)
{
	Audio * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_AUDIO, Audio);
	switch (property_id) {
		case AUDIO_SINKS_PROPERTY:
		{
			int length;
			g_value_set_boxed (value, audio_get_sinks (self, &length));
		}
		break;
		case AUDIO_DEFAULT_SINK_NAME_PROPERTY:
		g_value_set_string (value, audio_get_default_sink_name (self));
		break;
		case AUDIO_DEFAULT_SINK_ID_PROPERTY:
		g_value_set_int (value, audio_get_default_sink_id (self));
		break;
		case AUDIO_DEFAULT_SINK_ICON_NAME_PROPERTY:
		g_value_set_string (value, audio_get_default_sink_icon_name (self));
		break;
		case AUDIO_DEFAULT_SINK_VOLUME_PROPERTY:
		g_value_set_int (value, audio_get_default_sink_volume (self));
		break;
		case AUDIO_DEFAULT_SINK_MUTE_PROPERTY:
		g_value_set_boolean (value, audio_get_default_sink_mute (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_audio_set_property (GObject * object,
                          guint property_id,
                          const GValue * value,
                          GParamSpec * pspec)
{
	Audio * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_AUDIO, Audio);
	switch (property_id) {
		case AUDIO_SINKS_PROPERTY:
		{
			gpointer boxed;
			boxed = g_value_get_boxed (value);
			audio_set_sinks (self, boxed, (boxed == NULL) ? 0 : g_strv_length (boxed));
		}
		break;
		case AUDIO_DEFAULT_SINK_NAME_PROPERTY:
		audio_set_default_sink_name (self, g_value_get_string (value));
		break;
		case AUDIO_DEFAULT_SINK_ID_PROPERTY:
		audio_set_default_sink_id (self, g_value_get_int (value));
		break;
		case AUDIO_DEFAULT_SINK_ICON_NAME_PROPERTY:
		audio_set_default_sink_icon_name (self, g_value_get_string (value));
		break;
		case AUDIO_DEFAULT_SINK_VOLUME_PROPERTY:
		audio_set_default_sink_volume (self, g_value_get_int (value));
		break;
		case AUDIO_DEFAULT_SINK_MUTE_PROPERTY:
		audio_set_default_sink_mute (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

