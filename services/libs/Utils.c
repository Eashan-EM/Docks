/* Utils.c generated by valac 0.56.16, the Vala compiler
 * generated from Utils.vala, do not modify */

#include "Utils.h"
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <gdk/gdk.h>
#include <stdio.h>
#include <gio/gio.h>
#include <glib-object.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
enum  {
	UTILS_EXEC_THREADS_0_PROPERTY,
	UTILS_EXEC_THREADS_NUM_PROPERTIES
};
static GParamSpec* utils_exec_threads_properties[UTILS_EXEC_THREADS_NUM_PROPERTIES];
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
enum  {
	UTILS_EXEC_THREADS_OUTPUT_SIGNAL,
	UTILS_EXEC_THREADS_NUM_SIGNALS
};
static guint utils_exec_threads_signals[UTILS_EXEC_THREADS_NUM_SIGNALS] = {0};
enum  {
	UTILS_TIME_THREADS_0_PROPERTY,
	UTILS_TIME_THREADS_NUM_PROPERTIES
};
static GParamSpec* utils_time_threads_properties[UTILS_TIME_THREADS_NUM_PROPERTIES];
enum  {
	UTILS_TIME_THREADS_OUTPUT_SIGNAL,
	UTILS_TIME_THREADS_NUM_SIGNALS
};
static guint utils_time_threads_signals[UTILS_TIME_THREADS_NUM_SIGNALS] = {0};

struct _UtilsExec_ThreadsPrivate {
	gchar* str;
	gchar** command;
	gint command_length1;
	gint _command_size_;
	GThread* thread;
	gchar* name;
	GSubprocess* process;
	GInputStream* inp;
};

struct _UtilsTime_ThreadsPrivate {
	gchar* str;
	gint time;
	gchar** command;
	gint command_length1;
	gint _command_size_;
	GThread* thread;
	gchar* name;
	GSubprocess* process;
	GInputStream* inp;
};

static gint UtilsExec_Threads_private_offset;
static gpointer utils_exec_threads_parent_class = NULL;
static gint UtilsTime_Threads_private_offset;
static gpointer utils_time_threads_parent_class = NULL;

static void utils_exec_threads_close (UtilsExec_Threads* self);
static gchar** _vala_array_dup1 (gchar** self,
                          gssize length);
static void utils_exec_threads_execute (UtilsExec_Threads* self);
static gpointer _utils_exec_threads_execute_gthread_func (gpointer self);
static void utils_exec_threads_finalize (GObject * obj);
static GType utils_exec_threads_get_type_once (void);
static void utils_time_threads_close (UtilsTime_Threads* self);
static gchar** _vala_array_dup2 (gchar** self,
                          gssize length);
static void utils_time_threads_execute (UtilsTime_Threads* self);
static gpointer _utils_time_threads_execute_gthread_func (gpointer self);
static void utils_time_threads_finalize (GObject * obj);
static GType utils_time_threads_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

void
utils_add_class (GtkWidget* wid,
                 const gchar* class_name)
{
	g_return_if_fail (wid != NULL);
	g_return_if_fail (class_name != NULL);
	if (wid != NULL) {
		GtkStyleContext* context = NULL;
		GtkStyleContext* _tmp0_;
		GtkStyleContext* _tmp1_;
		GtkStyleContext* _tmp2_;
		_tmp0_ = gtk_widget_get_style_context (wid);
		_tmp1_ = _g_object_ref0 (_tmp0_);
		context = _tmp1_;
		_tmp2_ = context;
		gtk_style_context_add_class (_tmp2_, class_name);
		_g_object_unref0 (context);
	}
}

void
utils_remove_class (GtkWidget* wid,
                    const gchar* class_name)
{
	g_return_if_fail (wid != NULL);
	g_return_if_fail (class_name != NULL);
	if (wid != NULL) {
		GtkStyleContext* context = NULL;
		GtkStyleContext* _tmp0_;
		GtkStyleContext* _tmp1_;
		GtkStyleContext* _tmp2_;
		_tmp0_ = gtk_widget_get_style_context (wid);
		_tmp1_ = _g_object_ref0 (_tmp0_);
		context = _tmp1_;
		_tmp2_ = context;
		gtk_style_context_remove_class (_tmp2_, class_name);
		_g_object_unref0 (context);
	}
}

void
utils_load_style (const gchar* file_name)
{
	GtkCssProvider* css_provider = NULL;
	GtkCssProvider* _tmp0_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (file_name != NULL);
	_tmp0_ = gtk_css_provider_new ();
	css_provider = _tmp0_;
	{
		GdkScreen* _tmp1_;
		gtk_css_provider_load_from_path (css_provider, file_name, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp1_ = gdk_screen_get_default ();
		gtk_style_context_add_provider_for_screen (_tmp1_, (GtkStyleProvider*) css_provider, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp2_;
		GError* _tmp3_;
		const gchar* _tmp4_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp2_ = stdout;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		fprintf (_tmp2_, "Cannot read css file: %s\n", _tmp4_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (css_provider);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_g_object_unref0 (css_provider);
}

gchar*
utils_curr_dir (void)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* result;
	_tmp0_ = g_getenv ("PWD");
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}

gchar*
utils_exec (gchar** command,
            gint command_length1)
{
	GSubprocess* process = NULL;
	GSubprocess* _tmp0_;
	GInputStream* inp = NULL;
	GSubprocess* _tmp1_;
	GInputStream* _tmp2_;
	GInputStream* _tmp3_;
	gchar* output = NULL;
	gchar* _tmp4_;
	guint8* buf = NULL;
	gint buf_length1 = 0;
	gint _buf_size_ = 0;
	gint64 bytes_read = 0LL;
	GInputStream* _tmp13_;
	GSubprocess* _tmp14_;
	GError* _inner_error0_ = NULL;
	gchar* result;
	_tmp0_ = g_subprocess_newv (command, G_SUBPROCESS_FLAGS_STDOUT_PIPE, &_inner_error0_);
	process = _tmp0_;
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	_tmp1_ = process;
	_tmp2_ = g_subprocess_get_stdout_pipe (_tmp1_);
	_tmp3_ = _g_object_ref0 (_tmp2_);
	inp = _tmp3_;
	_tmp4_ = g_strdup ("");
	output = _tmp4_;
	bytes_read = (gint64) 0;
	{
		gboolean _tmp5_ = FALSE;
		_tmp5_ = TRUE;
		while (TRUE) {
			guint8* _tmp6_;
			GInputStream* _tmp7_;
			guint8* _tmp8_;
			gint _tmp8__length1;
			gsize _tmp9_ = 0UL;
			const gchar* _tmp10_;
			guint8* _tmp11_;
			gint _tmp11__length1;
			gchar* _tmp12_;
			if (!_tmp5_) {
				if (!(bytes_read == ((gint64) 512))) {
					break;
				}
			}
			_tmp5_ = FALSE;
			_tmp6_ = g_new0 (guint8, 512);
			buf = (g_free (buf), NULL);
			buf = _tmp6_;
			buf_length1 = 512;
			_buf_size_ = buf_length1;
			_tmp7_ = inp;
			_tmp8_ = buf;
			_tmp8__length1 = buf_length1;
			g_input_stream_read_all (_tmp7_, _tmp8_, (gsize) _tmp8__length1, &_tmp9_, NULL, &_inner_error0_);
			bytes_read = (gint64) _tmp9_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				buf = (g_free (buf), NULL);
				_g_free0 (output);
				_g_object_unref0 (inp);
				_g_object_unref0 (process);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
			_tmp10_ = output;
			_tmp11_ = buf;
			_tmp11__length1 = buf_length1;
			_tmp12_ = g_strconcat (_tmp10_, (const gchar*) _tmp11_, NULL);
			_g_free0 (output);
			output = _tmp12_;
		}
	}
	_tmp13_ = inp;
	g_input_stream_close (_tmp13_, NULL, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		buf = (g_free (buf), NULL);
		_g_free0 (output);
		_g_object_unref0 (inp);
		_g_object_unref0 (process);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	_tmp14_ = process;
	g_subprocess_force_exit (_tmp14_);
	result = output;
	buf = (g_free (buf), NULL);
	_g_object_unref0 (inp);
	_g_object_unref0 (process);
	return result;
}

static inline gpointer
utils_exec_threads_get_instance_private (UtilsExec_Threads* self)
{
	return G_STRUCT_MEMBER_P (self, UtilsExec_Threads_private_offset);
}

static gchar**
_vala_array_dup1 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

UtilsExec_Threads*
utils_exec_threads_construct (GType object_type,
                              gchar** command,
                              gint command_length1,
                              const gchar* name)
{
	UtilsExec_Threads * self = NULL;
	gchar** _tmp0_;
	gint _tmp0__length1;
	gchar* _tmp1_;
	g_return_val_if_fail (name != NULL, NULL);
	self = (UtilsExec_Threads*) g_object_new (object_type, NULL);
	_tmp0_ = (command != NULL) ? _vala_array_dup1 (command, command_length1) : command;
	_tmp0__length1 = command_length1;
	self->priv->command = (_vala_array_free (self->priv->command, self->priv->command_length1, (GDestroyNotify) g_free), NULL);
	self->priv->command = _tmp0_;
	self->priv->command_length1 = _tmp0__length1;
	self->priv->_command_size_ = self->priv->command_length1;
	_tmp1_ = g_strdup (name);
	_g_free0 (self->priv->name);
	self->priv->name = _tmp1_;
	return self;
}

UtilsExec_Threads*
utils_exec_threads_new (gchar** command,
                        gint command_length1,
                        const gchar* name)
{
	return utils_exec_threads_construct (UTILS_TYPE_EXEC_THREADS, command, command_length1, name);
}

static void
utils_exec_threads_close (UtilsExec_Threads* self)
{
	gboolean _tmp0_ = FALSE;
	GSubprocess* _tmp1_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->priv->process;
	if (_tmp1_ != NULL) {
		GInputStream* _tmp2_;
		_tmp2_ = self->priv->inp;
		_tmp0_ = _tmp2_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GInputStream* _tmp3_;
		GSubprocess* _tmp4_;
		_tmp3_ = self->priv->inp;
		g_input_stream_close (_tmp3_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
		_tmp4_ = self->priv->process;
		g_subprocess_force_exit (_tmp4_);
	}
}

static gpointer
_utils_exec_threads_execute_gthread_func (gpointer self)
{
	gpointer result;
	utils_exec_threads_execute ((UtilsExec_Threads*) self);
	result = NULL;
	g_object_unref (self);
	return result;
}

void
utils_exec_threads_start (UtilsExec_Threads* self)
{
	const gchar* _tmp0_;
	GThread* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->name;
	_tmp1_ = g_thread_new (_tmp0_, _utils_exec_threads_execute_gthread_func, g_object_ref (self));
	_g_thread_unref0 (self->priv->thread);
	self->priv->thread = _tmp1_;
}

static void
utils_exec_threads_execute (UtilsExec_Threads* self)
{
	GSubprocess* _tmp0_ = NULL;
	gchar** _tmp1_;
	gint _tmp1__length1;
	GSubprocess* _tmp2_;
	GSubprocess* _tmp3_;
	GSubprocess* _tmp4_;
	GInputStream* _tmp5_;
	GInputStream* _tmp6_;
	gint64 bytes_read = 0LL;
	guint8* buf = NULL;
	gint buf_length1 = 0;
	gint _buf_size_ = 0;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->priv->command;
	_tmp1__length1 = self->priv->command_length1;
	_tmp2_ = g_subprocess_newv (_tmp1_, G_SUBPROCESS_FLAGS_STDOUT_PIPE, &_inner_error0_);
	_tmp0_ = _tmp2_;
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp3_ = _tmp0_;
	_tmp0_ = NULL;
	_g_object_unref0 (self->priv->process);
	self->priv->process = _tmp3_;
	_tmp4_ = self->priv->process;
	_tmp5_ = g_subprocess_get_stdout_pipe (_tmp4_);
	_tmp6_ = _g_object_ref0 (_tmp5_);
	_g_object_unref0 (self->priv->inp);
	self->priv->inp = _tmp6_;
	bytes_read = (gint64) 0;
	while (TRUE) {
		GInputStream* _tmp7_;
		gchar* _tmp8_;
		const gchar* _tmp16_;
		gchar** _tmp17_;
		gchar** _tmp18_;
		_tmp7_ = self->priv->inp;
		if (!(!g_input_stream_is_closed (_tmp7_))) {
			break;
		}
		_tmp8_ = g_strdup ("");
		_g_free0 (self->priv->str);
		self->priv->str = _tmp8_;
		{
			gboolean _tmp9_ = FALSE;
			_tmp9_ = TRUE;
			while (TRUE) {
				guint8* _tmp10_;
				GInputStream* _tmp11_;
				guint8* _tmp12_;
				gint _tmp12__length1;
				const gchar* _tmp13_;
				guint8* _tmp14_;
				gint _tmp14__length1;
				gchar* _tmp15_;
				if (!_tmp9_) {
					if (!(bytes_read == ((gint64) 512))) {
						break;
					}
				}
				_tmp9_ = FALSE;
				_tmp10_ = g_new0 (guint8, 512);
				buf = (g_free (buf), NULL);
				buf = _tmp10_;
				buf_length1 = 512;
				_buf_size_ = buf_length1;
				_tmp11_ = self->priv->inp;
				_tmp12_ = buf;
				_tmp12__length1 = buf_length1;
				g_input_stream_read (_tmp11_, _tmp12_, (gsize) _tmp12__length1, NULL, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					buf = (g_free (buf), NULL);
					_g_object_unref0 (_tmp0_);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return;
				}
				_tmp13_ = self->priv->str;
				_tmp14_ = buf;
				_tmp14__length1 = buf_length1;
				_tmp15_ = g_strconcat (_tmp13_, (const gchar*) _tmp14_, NULL);
				_g_free0 (self->priv->str);
				self->priv->str = _tmp15_;
			}
		}
		_tmp16_ = self->priv->str;
		_tmp18_ = _tmp17_ = g_strsplit (_tmp16_, "\n", 0);
		{
			gchar** s_collection = NULL;
			gint s_collection_length1 = 0;
			gint _s_collection_size_ = 0;
			gint s_it = 0;
			s_collection = _tmp18_;
			s_collection_length1 = _vala_array_length (_tmp17_);
			for (s_it = 0; s_it < s_collection_length1; s_it = s_it + 1) {
				gchar* _tmp19_;
				gchar* s = NULL;
				_tmp19_ = g_strdup (s_collection[s_it]);
				s = _tmp19_;
				{
					const gchar* _tmp20_;
					_tmp20_ = s;
					if (g_strcmp0 (_tmp20_, "") != 0) {
						const gchar* _tmp21_;
						_tmp21_ = s;
						g_signal_emit (self, utils_exec_threads_signals[UTILS_EXEC_THREADS_OUTPUT_SIGNAL], 0, _tmp21_);
					}
					_g_free0 (s);
				}
			}
			s_collection = (_vala_array_free (s_collection, s_collection_length1, (GDestroyNotify) g_free), NULL);
		}
	}
	buf = (g_free (buf), NULL);
	_g_object_unref0 (_tmp0_);
}

static void
utils_exec_threads_class_init (UtilsExec_ThreadsClass * klass,
                               gpointer klass_data)
{
	utils_exec_threads_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &UtilsExec_Threads_private_offset);
	G_OBJECT_CLASS (klass)->finalize = utils_exec_threads_finalize;
	utils_exec_threads_signals[UTILS_EXEC_THREADS_OUTPUT_SIGNAL] = g_signal_new ("output", UTILS_TYPE_EXEC_THREADS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}

static void
utils_exec_threads_instance_init (UtilsExec_Threads * self,
                                  gpointer klass)
{
	gchar* _tmp0_;
	self->priv = utils_exec_threads_get_instance_private (self);
	_tmp0_ = g_strdup ("");
	self->priv->str = _tmp0_;
}

static void
utils_exec_threads_finalize (GObject * obj)
{
	UtilsExec_Threads * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UTILS_TYPE_EXEC_THREADS, UtilsExec_Threads);
	utils_exec_threads_close (self);
	_g_free0 (self->priv->str);
	self->priv->command = (_vala_array_free (self->priv->command, self->priv->command_length1, (GDestroyNotify) g_free), NULL);
	_g_thread_unref0 (self->priv->thread);
	_g_free0 (self->priv->name);
	_g_object_unref0 (self->priv->process);
	_g_object_unref0 (self->priv->inp);
	G_OBJECT_CLASS (utils_exec_threads_parent_class)->finalize (obj);
}

static GType
utils_exec_threads_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (UtilsExec_ThreadsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) utils_exec_threads_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UtilsExec_Threads), 0, (GInstanceInitFunc) utils_exec_threads_instance_init, NULL };
	GType utils_exec_threads_type_id;
	utils_exec_threads_type_id = g_type_register_static (G_TYPE_OBJECT, "UtilsExec_Threads", &g_define_type_info, 0);
	UtilsExec_Threads_private_offset = g_type_add_instance_private (utils_exec_threads_type_id, sizeof (UtilsExec_ThreadsPrivate));
	return utils_exec_threads_type_id;
}

GType
utils_exec_threads_get_type (void)
{
	static volatile gsize utils_exec_threads_type_id__once = 0;
	if (g_once_init_enter (&utils_exec_threads_type_id__once)) {
		GType utils_exec_threads_type_id;
		utils_exec_threads_type_id = utils_exec_threads_get_type_once ();
		g_once_init_leave (&utils_exec_threads_type_id__once, utils_exec_threads_type_id);
	}
	return utils_exec_threads_type_id__once;
}

static inline gpointer
utils_time_threads_get_instance_private (UtilsTime_Threads* self)
{
	return G_STRUCT_MEMBER_P (self, UtilsTime_Threads_private_offset);
}

static gchar**
_vala_array_dup2 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

UtilsTime_Threads*
utils_time_threads_construct (GType object_type,
                              gint time,
                              gchar** command,
                              gint command_length1,
                              const gchar* name)
{
	UtilsTime_Threads * self = NULL;
	gchar** _tmp0_;
	gint _tmp0__length1;
	gchar* _tmp1_;
	g_return_val_if_fail (name != NULL, NULL);
	self = (UtilsTime_Threads*) g_object_new (object_type, NULL);
	self->priv->time = time;
	_tmp0_ = (command != NULL) ? _vala_array_dup2 (command, command_length1) : command;
	_tmp0__length1 = command_length1;
	self->priv->command = (_vala_array_free (self->priv->command, self->priv->command_length1, (GDestroyNotify) g_free), NULL);
	self->priv->command = _tmp0_;
	self->priv->command_length1 = _tmp0__length1;
	self->priv->_command_size_ = self->priv->command_length1;
	_tmp1_ = g_strdup (name);
	_g_free0 (self->priv->name);
	self->priv->name = _tmp1_;
	return self;
}

UtilsTime_Threads*
utils_time_threads_new (gint time,
                        gchar** command,
                        gint command_length1,
                        const gchar* name)
{
	return utils_time_threads_construct (UTILS_TYPE_TIME_THREADS, time, command, command_length1, name);
}

static void
utils_time_threads_close (UtilsTime_Threads* self)
{
	gboolean _tmp0_ = FALSE;
	GSubprocess* _tmp1_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->priv->process;
	if (_tmp1_ != NULL) {
		GInputStream* _tmp2_;
		_tmp2_ = self->priv->inp;
		_tmp0_ = _tmp2_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GInputStream* _tmp3_;
		GSubprocess* _tmp4_;
		_tmp3_ = self->priv->inp;
		g_input_stream_close (_tmp3_, NULL, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
		_tmp4_ = self->priv->process;
		g_subprocess_force_exit (_tmp4_);
	}
}

static gpointer
_utils_time_threads_execute_gthread_func (gpointer self)
{
	gpointer result;
	utils_time_threads_execute ((UtilsTime_Threads*) self);
	result = NULL;
	g_object_unref (self);
	return result;
}

void
utils_time_threads_start (UtilsTime_Threads* self)
{
	const gchar* _tmp0_;
	GThread* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->name;
	_tmp1_ = g_thread_new (_tmp0_, _utils_time_threads_execute_gthread_func, g_object_ref (self));
	_g_thread_unref0 (self->priv->thread);
	self->priv->thread = _tmp1_;
}

static void
utils_time_threads_execute (UtilsTime_Threads* self)
{
	gint64 bytes_read = 0LL;
	guint8* buf = NULL;
	gint buf_length1 = 0;
	gint _buf_size_ = 0;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	bytes_read = (gint64) 128;
	while (TRUE) {
		GSubprocess* _tmp0_ = NULL;
		gchar** _tmp1_;
		gint _tmp1__length1;
		GSubprocess* _tmp2_;
		GSubprocess* _tmp3_;
		GSubprocess* _tmp4_;
		GInputStream* _tmp5_;
		GInputStream* _tmp6_;
		gchar* _tmp7_;
		const gchar* _tmp16_;
		gchar* _tmp17_;
		gchar* _tmp18_;
		gchar** _tmp19_;
		gchar** _tmp20_;
		gint _tmp20__length1;
		gchar* _tmp21_;
		gchar* _tmp22_;
		_tmp1_ = self->priv->command;
		_tmp1__length1 = self->priv->command_length1;
		_tmp2_ = g_subprocess_newv (_tmp1_, G_SUBPROCESS_FLAGS_STDOUT_PIPE, &_inner_error0_);
		_tmp0_ = _tmp2_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			buf = (g_free (buf), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
		_tmp3_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (self->priv->process);
		self->priv->process = _tmp3_;
		_tmp4_ = self->priv->process;
		_tmp5_ = g_subprocess_get_stdout_pipe (_tmp4_);
		_tmp6_ = _g_object_ref0 (_tmp5_);
		_g_object_unref0 (self->priv->inp);
		self->priv->inp = _tmp6_;
		_tmp7_ = g_strdup ("");
		_g_free0 (self->priv->str);
		self->priv->str = _tmp7_;
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = TRUE;
			while (TRUE) {
				guint8* _tmp9_;
				GInputStream* _tmp10_;
				guint8* _tmp11_;
				gint _tmp11__length1;
				gsize _tmp12_ = 0UL;
				const gchar* _tmp13_;
				guint8* _tmp14_;
				gint _tmp14__length1;
				gchar* _tmp15_;
				if (!_tmp8_) {
					if (!(bytes_read == ((gint64) 128))) {
						break;
					}
				}
				_tmp8_ = FALSE;
				_tmp9_ = g_new0 (guint8, 128);
				buf = (g_free (buf), NULL);
				buf = _tmp9_;
				buf_length1 = 128;
				_buf_size_ = buf_length1;
				_tmp10_ = self->priv->inp;
				_tmp11_ = buf;
				_tmp11__length1 = buf_length1;
				g_input_stream_read_all (_tmp10_, _tmp11_, (gsize) _tmp11__length1, &_tmp12_, NULL, &_inner_error0_);
				bytes_read = (gint64) _tmp12_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					_g_object_unref0 (_tmp0_);
					buf = (g_free (buf), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return;
				}
				_tmp13_ = self->priv->str;
				_tmp14_ = buf;
				_tmp14__length1 = buf_length1;
				_tmp15_ = g_strconcat (_tmp13_, (const gchar*) _tmp14_, NULL);
				_g_free0 (self->priv->str);
				self->priv->str = _tmp15_;
			}
		}
		_tmp16_ = self->priv->str;
		g_signal_emit (self, utils_time_threads_signals[UTILS_TIME_THREADS_OUTPUT_SIGNAL], 0, _tmp16_);
		_tmp17_ = g_strdup ("sleep");
		_tmp18_ = g_strdup_printf ("%i", self->priv->time);
		_tmp19_ = g_new0 (gchar*, 2 + 1);
		_tmp19_[0] = _tmp17_;
		_tmp19_[1] = _tmp18_;
		_tmp20_ = _tmp19_;
		_tmp20__length1 = 2;
		_tmp21_ = utils_exec (_tmp20_, (gint) 2);
		_tmp22_ = _tmp21_;
		_g_free0 (_tmp22_);
		_tmp20_ = (_vala_array_free (_tmp20_, _tmp20__length1, (GDestroyNotify) g_free), NULL);
		utils_time_threads_close (self);
		_g_object_unref0 (_tmp0_);
	}
}

static void
utils_time_threads_class_init (UtilsTime_ThreadsClass * klass,
                               gpointer klass_data)
{
	utils_time_threads_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &UtilsTime_Threads_private_offset);
	G_OBJECT_CLASS (klass)->finalize = utils_time_threads_finalize;
	utils_time_threads_signals[UTILS_TIME_THREADS_OUTPUT_SIGNAL] = g_signal_new ("output", UTILS_TYPE_TIME_THREADS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}

static void
utils_time_threads_instance_init (UtilsTime_Threads * self,
                                  gpointer klass)
{
	gchar* _tmp0_;
	self->priv = utils_time_threads_get_instance_private (self);
	_tmp0_ = g_strdup ("");
	self->priv->str = _tmp0_;
}

static void
utils_time_threads_finalize (GObject * obj)
{
	UtilsTime_Threads * self;
	GThread* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UTILS_TYPE_TIME_THREADS, UtilsTime_Threads);
	utils_time_threads_close (self);
	_tmp0_ = self->priv->thread;
	g_thread_exit (_tmp0_);
	_g_free0 (self->priv->str);
	self->priv->command = (_vala_array_free (self->priv->command, self->priv->command_length1, (GDestroyNotify) g_free), NULL);
	_g_thread_unref0 (self->priv->thread);
	_g_free0 (self->priv->name);
	_g_object_unref0 (self->priv->process);
	_g_object_unref0 (self->priv->inp);
	G_OBJECT_CLASS (utils_time_threads_parent_class)->finalize (obj);
}

static GType
utils_time_threads_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (UtilsTime_ThreadsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) utils_time_threads_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UtilsTime_Threads), 0, (GInstanceInitFunc) utils_time_threads_instance_init, NULL };
	GType utils_time_threads_type_id;
	utils_time_threads_type_id = g_type_register_static (G_TYPE_OBJECT, "UtilsTime_Threads", &g_define_type_info, 0);
	UtilsTime_Threads_private_offset = g_type_add_instance_private (utils_time_threads_type_id, sizeof (UtilsTime_ThreadsPrivate));
	return utils_time_threads_type_id;
}

GType
utils_time_threads_get_type (void)
{
	static volatile gsize utils_time_threads_type_id__once = 0;
	if (g_once_init_enter (&utils_time_threads_type_id__once)) {
		GType utils_time_threads_type_id;
		utils_time_threads_type_id = utils_time_threads_get_type_once ();
		g_once_init_leave (&utils_time_threads_type_id__once, utils_time_threads_type_id);
	}
	return utils_time_threads_type_id__once;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

